module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output reg [3:0] count,
    output counting,
    output done,
    input ack );

	parameter S=4'd0, S1=4'd1, S11=4'd2, S110=4'd3, B0=4'd4, B1=4'd5, B2=4'd6, B3=4'd7, Count=4'd8, Wait=4'd9;
    reg [3:0] state,next;
    wire shift_ena;
    reg [9:0] counter;
    always @(posedge clk) begin
        if(reset) state<=S;
        else state<=next;
    end
    
    always @(*) begin
        case(state)
            S: next = data?S1:S;
            S1: next = data? S11:S;
            S11: next = data?S11: S110;
            S110: next = data?B0:S;
            B0: next = B1;
            B1: next = B2;
            B2: next = B3;
            B3: next = Count;
            Count: next = (count == 4'd0 & counter==10'd999)?Wait:Count;
            Wait: next = ack?S:Wait;
            default: next = S;
        endcase
    end
    
    
    always @(posedge clk) begin
        if(reset) begin
           count<=4'd0;
            counter =10'd0;
        end
        else if (shift_ena) begin
            count<={count[2:0],data}; 
        end
        else if(counting) begin
            if(count>=0) begin
                counter<= (counter==10'd999)? 10'd0:counter+10'd1;
                count<=(counter==10'd999)?count-4'd1:count;
            end
        end
    end
    assign shift_ena=(state==B0 | state==B1 | state==B2 | state==B3);
        assign done =(state==Wait);
    assign counting  = (state==Count);
            
endmodule

