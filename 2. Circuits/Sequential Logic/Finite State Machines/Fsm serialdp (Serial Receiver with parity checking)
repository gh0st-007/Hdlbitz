module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); 
    parameter idle=0, start=1, data=2, stop=3, error=4, odd=5;
    reg [2:0] state, state_next;
    
    //data cnt
    reg [3:0] cnt_data;
    always @(posedge clk) begin
        if(reset) cnt_data <= 0;
        else begin
            if(state_next==start) cnt_data <= 0;
            else begin
                if(state_next==data) cnt_data <= cnt_data+1;
                else cnt_data <= cnt_data;
            end
        end
    end
    
    //logic transition
    always @(*) begin
        case(state)
            idle: state_next = in ? idle : start;
            start: state_next = data;
            data: state_next = (cnt_data==8) ? odd : data;
            odd:  state_next = in ? stop : error;
            stop: state_next = in ? idle : start;
            error: state_next = in ? idle : error;
        endcase
    end
    
    //ff transition
    always @(posedge clk) begin
        if(reset) state <= idle;
        else state <= state_next;
    end
    
    //done
    reg done_r;
    always @(posedge clk) begin
        if(state_next==stop) done_r <= 1'b1;
        else done_r <= 1'b0;
    end

    
    // Datapath to latch input bits.
    reg [7:0] out_r;
    always @(posedge clk) begin
        if(reset) out_r <= 0;
        else begin
            case(state_next)
                start: out_r <= 0;
                data : out_r <= {in, out_r[7:1]};
                default: out_r <= out_r;
            endcase
        end
    end
    
    //Add parity checking


    reg is_odd;
    always @(posedge clk) begin
        if (reset | (state_next==start)) is_odd <= 0;
        else if (state_next==data || state_next==odd) begin
            if(in) is_odd <= ~is_odd;
            else is_odd <= is_odd;
        end
   		else is_odd <= is_odd;
    end
    
    
    assign done = done_r & is_odd;
    assign out_byte = out_r;

endmodule
